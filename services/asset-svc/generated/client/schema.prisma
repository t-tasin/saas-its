generator client {
  provider        = "prisma-client-js"
  output          = "../generated/client"
  binaryTargets   = ["native", "debian-openssl-3.0.x", "linux-arm64-openssl-3.0.x"]
  previewFeatures = ["multiSchema"]
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
  schemas           = ["asset"]
}

enum AssetStatus {
  available
  assigned
  maintenance
  retired

  @@schema("asset")
}

model AssetType {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now())

  assets Asset[]

  @@map("AssetType")
  @@schema("asset")
}

model Asset {
  id          String @id @default(uuid())
  assetId     String @unique // Renamed from assetTag (e.g., LAP-2024-001)
  type        String // Direct type string (e.g., "Laptop")
  description String // Renamed from summary - more detailed

  // Mandatory field
  fundingDepartment String

  // Hardware details
  manufacturer    String?
  model           String?
  modelGeneration String?
  serialNumber    String? @unique
  vendor          String?

  // Technical specifications
  memory        String?
  hddSize       String?
  hddType       String?
  cpuGeneration String?
  cpuSpeed      String?
  gpuModel      String?
  videoCard     String?

  // Network specifications
  wiredMac    String?
  wirelessMac String?

  // Display outputs
  output1 String?
  output2 String?

  // Procurement information
  receivedDate DateTime?
  cost         Float?
  po           String? // Purchase order number

  // Disposal information
  disposalDate DateTime?
  disposalType String?

  // Location and status
  location String?
  status   AssetStatus @default(available)

  // Assignment tracking (flattened from AssetAssignment)
  assignedToId    String? // User ID
  assignedToName  String? // User name
  assignedToEmail String? // User email
  assignedDate    DateTime?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations kept for backward compatibility
  assetTypeId String? // Made optional for transition
  assetType   AssetType?        @relation(fields: [assetTypeId], references: [id])
  assignments AssetAssignment[]
  lifecycle   LifecycleEvent[]

  @@index([status])
  @@index([assetTypeId])
  @@index([assignedToId])
  @@index([type])
  @@map("Asset")
  @@schema("asset")
}

model AssetAssignment {
  id           String    @id @default(uuid())
  assetId      String
  personId     String // user ID
  personName   String? // user name
  personEmail  String? // user email
  assignedAt   DateTime  @default(now())
  unassignedAt DateTime?

  asset Asset @relation(fields: [assetId], references: [id], onDelete: Cascade)

  @@index([assetId, unassignedAt])
  @@index([personId])
  @@map("AssetAssignment")
  @@schema("asset")
}

model LifecycleEvent {
  id         String   @id @default(uuid())
  assetId    String
  action     String // created, updated, assigned, unassigned, maintenance, retired
  actorId    String?
  metadata   Json?
  occurredAt DateTime @default(now())

  asset Asset @relation(fields: [assetId], references: [id], onDelete: Cascade)

  @@index([assetId, occurredAt])
  @@map("LifecycleEvent")
  @@schema("asset")
}

// Append-only audit log
model AuditLog {
  id       String   @id @default(uuid())
  entity   String
  entityId String
  action   String
  actorId  String?
  at       DateTime @default(now())
  metadata Json?

  @@index([entity, entityId, at])
  @@map("AuditLog")
  @@schema("asset")
}
